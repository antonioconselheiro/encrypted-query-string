{
  "version": 3,
  "sources": ["../../../../../node_modules/@noble/ciphers/esm/utils.js", "../../../../../node_modules/@noble/ciphers/esm/_assert.js", "../../../../../node_modules/@noble/ciphers/esm/_polyval.js", "../../../../../node_modules/@noble/ciphers/esm/aes.js", "../../../../../node_modules/@encrypted-uri/ciphers/index.js"],
  "sourcesContent": ["/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u16 = (arr) => new Uint16Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 2));\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    else if (isBytes(data))\n        data = data.slice();\n    else\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new Error('options must be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function ensureBytes(b, len) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (typeof len === 'number')\n        if (b.length !== len)\n            throw new Error(`Uint8Array length ${len} expected`);\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n// For runtime check if class implements interface\nexport class Hash {\n}\nexport const wrapCipher = (params, c) => {\n    Object.assign(c, params);\n    return c;\n};\n// Polyfill for Safari 14\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\nexport function u64Lengths(ciphertext, AAD) {\n    const num = new Uint8Array(16);\n    const view = createView(num);\n    setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    setBigUint64(view, 8, BigInt(ciphertext.length), true);\n    return num;\n}\n", "function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// TODO: merge with utils\nfunction isBytes(a) {\n    return (a != null &&\n        typeof a === 'object' &&\n        (a instanceof Uint8Array || a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('hash must be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n", "import { createView, toBytes, u32, ensureBytes } from './utils.js';\nimport { exists as aexists, output as aoutput } from './_assert.js';\n// GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n// Implemented in terms of GHash with conversion function for keys\n// GCM GHASH from NIST SP800-38d, SIV from RFC 8452.\n// https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\n// GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n// POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\nconst BLOCK_SIZE = 16;\n// TODO: rewrite\n// temporary padding buffer\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\nconst ZEROS32 = u32(ZEROS16);\nconst POLY = 0xe1; // v = 2*v % POLY\n// v = 2*v % POLY\n// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\nconst mul2 = (s0, s1, s2, s3) => {\n    const hiBit = s3 & 1;\n    return {\n        s3: (s2 << 31) | (s3 >>> 1),\n        s2: (s1 << 31) | (s2 >>> 1),\n        s1: (s0 << 31) | (s1 >>> 1),\n        s0: (s0 >>> 1) ^ ((POLY << 24) & -(hiBit & 1)), // reduce % poly\n    };\n};\nconst swapLE = (n) => (((n >>> 0) & 0xff) << 24) |\n    (((n >>> 8) & 0xff) << 16) |\n    (((n >>> 16) & 0xff) << 8) |\n    ((n >>> 24) & 0xff) |\n    0;\n/**\n * `mulX_POLYVAL(ByteReverse(H))` from spec\n * @param k mutated in place\n */\nexport function _toGHASHKey(k) {\n    k.reverse();\n    const hiBit = k[15] & 1;\n    // k >>= 1\n    let carry = 0;\n    for (let i = 0; i < k.length; i++) {\n        const t = k[i];\n        k[i] = (t >>> 1) | carry;\n        carry = (t & 1) << 7;\n    }\n    k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n    return k;\n}\nconst estimateWindow = (bytes) => {\n    if (bytes > 64 * 1024)\n        return 8;\n    if (bytes > 1024)\n        return 4;\n    return 2;\n};\nclass GHASH {\n    // We select bits per window adaptively based on expectedLength\n    constructor(key, expectedLength) {\n        this.blockLen = BLOCK_SIZE;\n        this.outputLen = BLOCK_SIZE;\n        this.s0 = 0;\n        this.s1 = 0;\n        this.s2 = 0;\n        this.s3 = 0;\n        this.finished = false;\n        key = toBytes(key);\n        ensureBytes(key, 16);\n        const kView = createView(key);\n        let k0 = kView.getUint32(0, false);\n        let k1 = kView.getUint32(4, false);\n        let k2 = kView.getUint32(8, false);\n        let k3 = kView.getUint32(12, false);\n        // generate table of doubled keys (half of montgomery ladder)\n        const doubles = [];\n        for (let i = 0; i < 128; i++) {\n            doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });\n            ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));\n        }\n        const W = estimateWindow(expectedLength || 1024);\n        if (![1, 2, 4, 8].includes(W))\n            throw new Error(`ghash: wrong window size=${W}, should be 2, 4 or 8`);\n        this.W = W;\n        const bits = 128; // always 128 bits;\n        const windows = bits / W;\n        const windowSize = (this.windowSize = 2 ** W);\n        const items = [];\n        // Create precompute table for window of W bits\n        for (let w = 0; w < windows; w++) {\n            // truth table: 00, 01, 10, 11\n            for (let byte = 0; byte < windowSize; byte++) {\n                // prettier-ignore\n                let s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n                for (let j = 0; j < W; j++) {\n                    const bit = (byte >>> (W - j - 1)) & 1;\n                    if (!bit)\n                        continue;\n                    const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];\n                    (s0 ^= d0), (s1 ^= d1), (s2 ^= d2), (s3 ^= d3);\n                }\n                items.push({ s0, s1, s2, s3 });\n            }\n        }\n        this.t = items;\n    }\n    _updateBlock(s0, s1, s2, s3) {\n        (s0 ^= this.s0), (s1 ^= this.s1), (s2 ^= this.s2), (s3 ^= this.s3);\n        const { W, t, windowSize } = this;\n        // prettier-ignore\n        let o0 = 0, o1 = 0, o2 = 0, o3 = 0;\n        const mask = (1 << W) - 1; // 2**W will kill performance.\n        let w = 0;\n        for (const num of [s0, s1, s2, s3]) {\n            for (let bytePos = 0; bytePos < 4; bytePos++) {\n                const byte = (num >>> (8 * bytePos)) & 0xff;\n                for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {\n                    const bit = (byte >>> (W * bitPos)) & mask;\n                    const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];\n                    (o0 ^= e0), (o1 ^= e1), (o2 ^= e2), (o3 ^= e3);\n                    w += 1;\n                }\n            }\n        }\n        this.s0 = o0;\n        this.s1 = o1;\n        this.s2 = o2;\n        this.s3 = o3;\n    }\n    update(data) {\n        data = toBytes(data);\n        aexists(this);\n        const b32 = u32(data);\n        const blocks = Math.floor(data.length / BLOCK_SIZE);\n        const left = data.length % BLOCK_SIZE;\n        for (let i = 0; i < blocks; i++) {\n            this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n        }\n        if (left) {\n            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n            this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);\n            ZEROS32.fill(0); // clean tmp buffer\n        }\n        return this;\n    }\n    destroy() {\n        const { t } = this;\n        // clean precompute table\n        for (const elm of t) {\n            (elm.s0 = 0), (elm.s1 = 0), (elm.s2 = 0), (elm.s3 = 0);\n        }\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        const { s0, s1, s2, s3 } = this;\n        const o32 = u32(out);\n        o32[0] = s0;\n        o32[1] = s1;\n        o32[2] = s2;\n        o32[3] = s3;\n        return out;\n    }\n    digest() {\n        const res = new Uint8Array(BLOCK_SIZE);\n        this.digestInto(res);\n        this.destroy();\n        return res;\n    }\n}\nclass Polyval extends GHASH {\n    constructor(key, expectedLength) {\n        key = toBytes(key);\n        const ghKey = _toGHASHKey(key.slice());\n        super(ghKey, expectedLength);\n        ghKey.fill(0);\n    }\n    update(data) {\n        data = toBytes(data);\n        aexists(this);\n        const b32 = u32(data);\n        const left = data.length % BLOCK_SIZE;\n        const blocks = Math.floor(data.length / BLOCK_SIZE);\n        for (let i = 0; i < blocks; i++) {\n            this._updateBlock(swapLE(b32[i * 4 + 3]), swapLE(b32[i * 4 + 2]), swapLE(b32[i * 4 + 1]), swapLE(b32[i * 4 + 0]));\n        }\n        if (left) {\n            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n            this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));\n            ZEROS32.fill(0); // clean tmp buffer\n        }\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // tmp ugly hack\n        const { s0, s1, s2, s3 } = this;\n        const o32 = u32(out);\n        o32[0] = s0;\n        o32[1] = s1;\n        o32[2] = s2;\n        o32[3] = s3;\n        return out.reverse();\n    }\n}\nfunction wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key, msg.length).update(toBytes(msg)).digest();\n    const tmp = hashCons(new Uint8Array(16), 0);\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key, expectedLength) => hashCons(key, expectedLength);\n    return hashC;\n}\nexport const ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));\nexport const polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));\n", "import { wrapCipher, equalBytes, u32, u8, ensureBytes } from './utils.js';\nimport { createView, setBigUint64 } from './utils.js';\nimport { ghash, polyval } from './_polyval.js';\n// AES (Advanced Encryption Standard) aka Rijndael block cipher.\n//\n// Data is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256bit). Every round:\n// 1. **S-box**, table substitution\n// 2. **Shift rows**, cyclic shift left of all rows of data array\n// 3. **Mix columns**, multiplying every column by fixed polynomial\n// 4. **Add round key**, round_key xor i-th column of array\n//\n// Resources:\n// - FIPS-197 https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf\n// - Original proposal: https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf\nconst BLOCK_SIZE = 16;\nconst BLOCK_SIZE32 = 4;\nconst EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE);\nconst POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n// TODO: remove multiplication, binary ops only\nfunction mul2(n) {\n    return (n << 1) ^ (POLY & -(n >> 7));\n}\nfunction mul(a, b) {\n    let res = 0;\n    for (; b > 0; b >>= 1) {\n        // Montgomery ladder\n        res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n        a = mul2(a); // a = 2*a\n    }\n    return res;\n}\n// AES S-box is generated using finite field inversion,\n// an affine transform, and xor of a constant 0x63.\nconst _sbox = /* @__PURE__ */ (() => {\n    let t = new Uint8Array(256);\n    for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x))\n        t[i] = x;\n    const sbox = new Uint8Array(256);\n    sbox[0] = 0x63; // first elm\n    for (let i = 0; i < 255; i++) {\n        let x = t[255 - i];\n        x |= x << 8;\n        sbox[t[i]] = (x ^ (x >> 4) ^ (x >> 5) ^ (x >> 6) ^ (x >> 7) ^ 0x63) & 0xff;\n    }\n    return sbox;\n})();\n// Inverted S-box\nconst _inv_sbox = /* @__PURE__ */ _sbox.map((_, j) => _sbox.indexOf(j));\n// Rotate u32 by 8\nconst rotr32_8 = (n) => (n << 24) | (n >>> 8);\nconst rotl32_8 = (n) => (n << 8) | (n >>> 24);\n// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n// - LE instead of BE\n// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n//   so index is u16, instead of u8. This speeds up things, unexpectedly\nfunction genTtable(sbox, fn) {\n    if (sbox.length !== 256)\n        throw new Error('Wrong sbox length');\n    const T0 = new Uint32Array(256).map((_, j) => fn(sbox[j]));\n    const T1 = T0.map(rotl32_8);\n    const T2 = T1.map(rotl32_8);\n    const T3 = T2.map(rotl32_8);\n    const T01 = new Uint32Array(256 * 256);\n    const T23 = new Uint32Array(256 * 256);\n    const sbox2 = new Uint16Array(256 * 256);\n    for (let i = 0; i < 256; i++) {\n        for (let j = 0; j < 256; j++) {\n            const idx = i * 256 + j;\n            T01[idx] = T0[i] ^ T1[j];\n            T23[idx] = T2[i] ^ T3[j];\n            sbox2[idx] = (sbox[i] << 8) | sbox[j];\n        }\n    }\n    return { sbox, sbox2, T0, T1, T2, T3, T01, T23 };\n}\nconst TABLE_ENC = /* @__PURE__ */ genTtable(_sbox, (s) => (mul(s, 3) << 24) | (s << 16) | (s << 8) | mul(s, 2));\nconst TABLE_DEC = /* @__PURE__ */ genTtable(_inv_sbox, (s) => (mul(s, 11) << 24) | (mul(s, 13) << 16) | (mul(s, 9) << 8) | mul(s, 14));\nconst POWX = /* @__PURE__ */ (() => {\n    const p = new Uint8Array(16);\n    for (let i = 0, x = 1; i < 16; i++, x = mul2(x))\n        p[i] = x;\n    return p;\n})();\nexport function expandKeyLE(key) {\n    ensureBytes(key);\n    const len = key.length;\n    if (![16, 24, 32].includes(len))\n        throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${len}`);\n    const { sbox2 } = TABLE_ENC;\n    const k32 = u32(key);\n    const Nk = k32.length;\n    const subByte = (n) => applySbox(sbox2, n, n, n, n);\n    const xk = new Uint32Array(len + 28); // expanded key\n    xk.set(k32);\n    // 4.3.1 Key expansion\n    for (let i = Nk; i < xk.length; i++) {\n        let t = xk[i - 1];\n        if (i % Nk === 0)\n            t = subByte(rotr32_8(t)) ^ POWX[i / Nk - 1];\n        else if (Nk > 6 && i % Nk === 4)\n            t = subByte(t);\n        xk[i] = xk[i - Nk] ^ t;\n    }\n    return xk;\n}\nexport function expandKeyDecLE(key) {\n    const encKey = expandKeyLE(key);\n    const xk = encKey.slice();\n    const Nk = encKey.length;\n    const { sbox2 } = TABLE_ENC;\n    const { T0, T1, T2, T3 } = TABLE_DEC;\n    // Inverse key by chunks of 4 (rounds)\n    for (let i = 0; i < Nk; i += 4) {\n        for (let j = 0; j < 4; j++)\n            xk[i + j] = encKey[Nk - i - 4 + j];\n    }\n    encKey.fill(0);\n    // apply InvMixColumn except first & last round\n    for (let i = 4; i < Nk - 4; i++) {\n        const x = xk[i];\n        const w = applySbox(sbox2, x, x, x, x);\n        xk[i] = T0[w & 0xff] ^ T1[(w >>> 8) & 0xff] ^ T2[(w >>> 16) & 0xff] ^ T3[w >>> 24];\n    }\n    return xk;\n}\n// Apply tables\nfunction apply0123(T01, T23, s0, s1, s2, s3) {\n    return (T01[((s0 << 8) & 0xff00) | ((s1 >>> 8) & 0xff)] ^\n        T23[((s2 >>> 8) & 0xff00) | ((s3 >>> 24) & 0xff)]);\n}\nfunction applySbox(sbox2, s0, s1, s2, s3) {\n    return (sbox2[(s0 & 0xff) | (s1 & 0xff00)] |\n        (sbox2[((s2 >>> 16) & 0xff) | ((s3 >>> 16) & 0xff00)] << 16));\n}\nfunction encrypt(xk, s0, s1, s2, s3) {\n    const { sbox2, T01, T23 } = TABLE_ENC;\n    let k = 0;\n    (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n    const rounds = xk.length / 4 - 2;\n    for (let i = 0; i < rounds; i++) {\n        const t0 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);\n        const t1 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);\n        const t2 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);\n        const t3 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);\n        (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n    }\n    // last round (without mixcolumns, so using SBOX2 table)\n    const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);\n    const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);\n    const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);\n    const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);\n    return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\nfunction decrypt(xk, s0, s1, s2, s3) {\n    const { sbox2, T01, T23 } = TABLE_DEC;\n    let k = 0;\n    (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n    const rounds = xk.length / 4 - 2;\n    for (let i = 0; i < rounds; i++) {\n        const t0 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);\n        const t1 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);\n        const t2 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);\n        const t3 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);\n        (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n    }\n    // Last round\n    const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);\n    const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);\n    const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);\n    const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);\n    return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\nfunction getDst(len, dst) {\n    if (!dst)\n        return new Uint8Array(len);\n    ensureBytes(dst);\n    if (dst.length < len)\n        throw new Error(`aes: wrong destination length, expected at least ${len}, got: ${dst.length}`);\n    return dst;\n}\n// TODO: investigate merging with ctr32\nfunction ctrCounter(xk, nonce, src, dst) {\n    ensureBytes(nonce, BLOCK_SIZE);\n    ensureBytes(src);\n    const srcLen = src.length;\n    dst = getDst(srcLen, dst);\n    const ctr = nonce;\n    const c32 = u32(ctr);\n    // Fill block (empty, ctr=0)\n    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n    const src32 = u32(src);\n    const dst32 = u32(dst);\n    // process blocks\n    for (let i = 0; i + 4 <= src32.length; i += 4) {\n        dst32[i + 0] = src32[i + 0] ^ s0;\n        dst32[i + 1] = src32[i + 1] ^ s1;\n        dst32[i + 2] = src32[i + 2] ^ s2;\n        dst32[i + 3] = src32[i + 3] ^ s3;\n        // Full 128 bit counter with wrap around\n        let carry = 1;\n        for (let i = ctr.length - 1; i >= 0; i--) {\n            carry = (carry + (ctr[i] & 0xff)) | 0;\n            ctr[i] = carry & 0xff;\n            carry >>>= 8;\n        }\n        ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n    }\n    // leftovers (less than block)\n    // It's possible to handle > u32 fast, but is it worth it?\n    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n    if (start < srcLen) {\n        const b32 = new Uint32Array([s0, s1, s2, s3]);\n        const buf = u8(b32);\n        for (let i = start, pos = 0; i < srcLen; i++, pos++)\n            dst[i] = src[i] ^ buf[pos];\n    }\n    return dst;\n}\n// AES CTR with overflowing 32 bit counter\n// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n// But, we need both, and perf bottleneck is in ghash anyway.\nfunction ctr32(xk, isLE, nonce, src, dst) {\n    ensureBytes(nonce, BLOCK_SIZE);\n    ensureBytes(src);\n    dst = getDst(src.length, dst);\n    const ctr = nonce; // write new value to nonce, so it can be re-used\n    const c32 = u32(ctr);\n    const view = createView(ctr);\n    const src32 = u32(src);\n    const dst32 = u32(dst);\n    const ctrPos = isLE ? 0 : 12;\n    const srcLen = src.length;\n    // Fill block (empty, ctr=0)\n    let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n    // process blocks\n    for (let i = 0; i + 4 <= src32.length; i += 4) {\n        dst32[i + 0] = src32[i + 0] ^ s0;\n        dst32[i + 1] = src32[i + 1] ^ s1;\n        dst32[i + 2] = src32[i + 2] ^ s2;\n        dst32[i + 3] = src32[i + 3] ^ s3;\n        ctrNum = (ctrNum + 1) >>> 0; // u32 wrap\n        view.setUint32(ctrPos, ctrNum, isLE);\n        ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n    }\n    // leftovers (less than a block)\n    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n    if (start < srcLen) {\n        const b32 = new Uint32Array([s0, s1, s2, s3]);\n        const buf = u8(b32);\n        for (let i = start, pos = 0; i < srcLen; i++, pos++)\n            dst[i] = src[i] ^ buf[pos];\n    }\n    return dst;\n}\n/**\n * CTR: counter mode. Creates stream cipher.\n * Requires good IV. Parallelizable. OK, but no MAC.\n */\nexport const ctr = wrapCipher({ blockSize: 16, nonceLength: 16 }, function ctr(key, nonce) {\n    ensureBytes(key);\n    ensureBytes(nonce, BLOCK_SIZE);\n    function processCtr(buf, dst) {\n        const xk = expandKeyLE(key);\n        const n = nonce.slice();\n        const out = ctrCounter(xk, n, buf, dst);\n        xk.fill(0);\n        n.fill(0);\n        return out;\n    }\n    return {\n        encrypt: (plaintext, dst) => processCtr(plaintext, dst),\n        decrypt: (ciphertext, dst) => processCtr(ciphertext, dst),\n    };\n});\nfunction validateBlockDecrypt(data) {\n    ensureBytes(data);\n    if (data.length % BLOCK_SIZE !== 0) {\n        throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE}`);\n    }\n}\nfunction validateBlockEncrypt(plaintext, pcks5, dst) {\n    let outLen = plaintext.length;\n    const remaining = outLen % BLOCK_SIZE;\n    if (!pcks5 && remaining !== 0)\n        throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n    const b = u32(plaintext);\n    if (pcks5) {\n        let left = BLOCK_SIZE - remaining;\n        if (!left)\n            left = BLOCK_SIZE; // if no bytes left, create empty padding block\n        outLen = outLen + left;\n    }\n    const out = getDst(outLen, dst);\n    const o = u32(out);\n    return { b, o, out };\n}\nfunction validatePCKS(data, pcks5) {\n    if (!pcks5)\n        return data;\n    const len = data.length;\n    if (!len)\n        throw new Error(`aes/pcks5: empty ciphertext not allowed`);\n    const lastByte = data[len - 1];\n    if (lastByte <= 0 || lastByte > 16)\n        throw new Error(`aes/pcks5: wrong padding byte: ${lastByte}`);\n    const out = data.subarray(0, -lastByte);\n    for (let i = 0; i < lastByte; i++)\n        if (data[len - i - 1] !== lastByte)\n            throw new Error(`aes/pcks5: wrong padding`);\n    return out;\n}\nfunction padPCKS(left) {\n    const tmp = new Uint8Array(16);\n    const tmp32 = u32(tmp);\n    tmp.set(left);\n    const paddingByte = BLOCK_SIZE - left.length;\n    for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++)\n        tmp[i] = paddingByte;\n    return tmp32;\n}\n/**\n * ECB: Electronic CodeBook. Simple deterministic replacement.\n * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n */\nexport const ecb = wrapCipher({ blockSize: 16 }, function ecb(key, opts = {}) {\n    ensureBytes(key);\n    const pcks5 = !opts.disablePadding;\n    return {\n        encrypt: (plaintext, dst) => {\n            ensureBytes(plaintext);\n            const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n            const xk = expandKeyLE(key);\n            let i = 0;\n            for (; i + 4 <= b.length;) {\n                const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            if (pcks5) {\n                const tmp32 = padPCKS(plaintext.subarray(i * 4));\n                const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return _out;\n        },\n        decrypt: (ciphertext, dst) => {\n            validateBlockDecrypt(ciphertext);\n            const xk = expandKeyDecLE(key);\n            const out = getDst(ciphertext.length, dst);\n            const b = u32(ciphertext);\n            const o = u32(out);\n            for (let i = 0; i + 4 <= b.length;) {\n                const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return validatePCKS(out, pcks5);\n        },\n    };\n});\n/**\n * CBC: Cipher-Block-Chaining. Key is previous round’s block.\n * Fragile: needs proper padding. Unauthenticated: needs MAC.\n */\nexport const cbc = wrapCipher({ blockSize: 16, nonceLength: 16 }, function cbc(key, iv, opts = {}) {\n    ensureBytes(key);\n    ensureBytes(iv, 16);\n    const pcks5 = !opts.disablePadding;\n    return {\n        encrypt: (plaintext, dst) => {\n            const xk = expandKeyLE(key);\n            const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n            const n32 = u32(iv);\n            // prettier-ignore\n            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n            let i = 0;\n            for (; i + 4 <= b.length;) {\n                (s0 ^= b[i + 0]), (s1 ^= b[i + 1]), (s2 ^= b[i + 2]), (s3 ^= b[i + 3]);\n                ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            if (pcks5) {\n                const tmp32 = padPCKS(plaintext.subarray(i * 4));\n                (s0 ^= tmp32[0]), (s1 ^= tmp32[1]), (s2 ^= tmp32[2]), (s3 ^= tmp32[3]);\n                ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return _out;\n        },\n        decrypt: (ciphertext, dst) => {\n            validateBlockDecrypt(ciphertext);\n            const xk = expandKeyDecLE(key);\n            const n32 = u32(iv);\n            const out = getDst(ciphertext.length, dst);\n            const b = u32(ciphertext);\n            const o = u32(out);\n            // prettier-ignore\n            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n            for (let i = 0; i + 4 <= b.length;) {\n                // prettier-ignore\n                const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;\n                (s0 = b[i + 0]), (s1 = b[i + 1]), (s2 = b[i + 2]), (s3 = b[i + 3]);\n                const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);\n                (o[i++] = o0 ^ ps0), (o[i++] = o1 ^ ps1), (o[i++] = o2 ^ ps2), (o[i++] = o3 ^ ps3);\n            }\n            xk.fill(0);\n            return validatePCKS(out, pcks5);\n        },\n    };\n});\n// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\nfunction computeTag(fn, isLE, key, data, AAD) {\n    const h = fn.create(key, data.length + (AAD?.length || 0));\n    if (AAD)\n        h.update(AAD);\n    h.update(data);\n    const num = new Uint8Array(16);\n    const view = createView(num);\n    if (AAD)\n        setBigUint64(view, 0, BigInt(AAD.length * 8), isLE);\n    setBigUint64(view, 8, BigInt(data.length * 8), isLE);\n    h.update(num);\n    return h.digest();\n}\n/**\n * GCM: Galois/Counter Mode.\n * Good, modern version of CTR, parallel, with MAC.\n * Be careful: MACs can be forged.\n */\nexport const gcm = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function gcm(key, nonce, AAD) {\n    ensureBytes(nonce);\n    // Nonce can be pretty much anything (even 1 byte). But smaller nonces less secure.\n    if (nonce.length === 0)\n        throw new Error('aes/gcm: empty nonce');\n    const tagLength = 16;\n    function _computeTag(authKey, tagMask, data) {\n        const tag = computeTag(ghash, false, authKey, data, AAD);\n        for (let i = 0; i < tagMask.length; i++)\n            tag[i] ^= tagMask[i];\n        return tag;\n    }\n    function deriveKeys() {\n        const xk = expandKeyLE(key);\n        const authKey = EMPTY_BLOCK.slice();\n        const counter = EMPTY_BLOCK.slice();\n        ctr32(xk, false, counter, counter, authKey);\n        if (nonce.length === 12) {\n            counter.set(nonce);\n        }\n        else {\n            // Spec (NIST 800-38d) supports variable size nonce.\n            // Not supported for now, but can be useful.\n            const nonceLen = EMPTY_BLOCK.slice();\n            const view = createView(nonceLen);\n            setBigUint64(view, 8, BigInt(nonce.length * 8), false);\n            // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n            ghash.create(authKey).update(nonce).update(nonceLen).digestInto(counter);\n        }\n        const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);\n        return { xk, authKey, counter, tagMask };\n    }\n    return {\n        encrypt: (plaintext) => {\n            ensureBytes(plaintext);\n            const { xk, authKey, counter, tagMask } = deriveKeys();\n            const out = new Uint8Array(plaintext.length + tagLength);\n            ctr32(xk, false, counter, plaintext, out);\n            const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n            out.set(tag, plaintext.length);\n            xk.fill(0);\n            return out;\n        },\n        decrypt: (ciphertext) => {\n            ensureBytes(ciphertext);\n            if (ciphertext.length < tagLength)\n                throw new Error(`aes/gcm: ciphertext less than tagLen (${tagLength})`);\n            const { xk, authKey, counter, tagMask } = deriveKeys();\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = _computeTag(authKey, tagMask, data);\n            if (!equalBytes(tag, passedTag))\n                throw new Error('aes/gcm: invalid ghash tag');\n            const out = ctr32(xk, false, counter, data);\n            authKey.fill(0);\n            tagMask.fill(0);\n            xk.fill(0);\n            return out;\n        },\n    };\n});\nconst limit = (name, min, max) => (value) => {\n    if (!Number.isSafeInteger(value) || min > value || value > max)\n        throw new Error(`${name}: invalid value=${value}, must be [${min}..${max}]`);\n};\n/**\n * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n * Guarantees that, when a nonce is repeated, the only security loss is that identical\n * plaintexts will produce identical ciphertexts.\n * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n */\nexport const siv = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function siv(key, nonce, AAD) {\n    const tagLength = 16;\n    // From RFC 8452: Section 6\n    const AAD_LIMIT = limit('AAD', 0, 2 ** 36);\n    const PLAIN_LIMIT = limit('plaintext', 0, 2 ** 36);\n    const NONCE_LIMIT = limit('nonce', 12, 12);\n    const CIPHER_LIMIT = limit('ciphertext', 16, 2 ** 36 + 16);\n    ensureBytes(nonce);\n    NONCE_LIMIT(nonce.length);\n    if (AAD) {\n        ensureBytes(AAD);\n        AAD_LIMIT(AAD.length);\n    }\n    function deriveKeys() {\n        const len = key.length;\n        if (len !== 16 && len !== 24 && len !== 32)\n            throw new Error(`key length must be 16, 24 or 32 bytes, got: ${len} bytes`);\n        const xk = expandKeyLE(key);\n        const encKey = new Uint8Array(len);\n        const authKey = new Uint8Array(16);\n        const n32 = u32(nonce);\n        // prettier-ignore\n        let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];\n        let counter = 0;\n        for (const derivedKey of [authKey, encKey].map(u32)) {\n            const d32 = u32(derivedKey);\n            for (let i = 0; i < d32.length; i += 2) {\n                // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n                const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);\n                d32[i + 0] = o0;\n                d32[i + 1] = o1;\n                s0 = ++counter; // increment counter inside state\n            }\n        }\n        xk.fill(0);\n        return { authKey, encKey: expandKeyLE(encKey) };\n    }\n    function _computeTag(encKey, authKey, data) {\n        const tag = computeTag(polyval, true, authKey, data, AAD);\n        // Compute the expected tag by XORing S_s and the nonce, clearing the\n        // most significant bit of the last byte and encrypting with the\n        // message-encryption key.\n        for (let i = 0; i < 12; i++)\n            tag[i] ^= nonce[i];\n        tag[15] &= 0x7f; // Clear the highest bit\n        // encrypt tag as block\n        const t32 = u32(tag);\n        // prettier-ignore\n        let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];\n        ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));\n        (t32[0] = s0), (t32[1] = s1), (t32[2] = s2), (t32[3] = s3);\n        return tag;\n    }\n    // actual decrypt/encrypt of message.\n    function processSiv(encKey, tag, input) {\n        let block = tag.slice();\n        block[15] |= 0x80; // Force highest bit\n        return ctr32(encKey, true, block, input);\n    }\n    return {\n        encrypt: (plaintext) => {\n            ensureBytes(plaintext);\n            PLAIN_LIMIT(plaintext.length);\n            const { encKey, authKey } = deriveKeys();\n            const tag = _computeTag(encKey, authKey, plaintext);\n            const out = new Uint8Array(plaintext.length + tagLength);\n            out.set(tag, plaintext.length);\n            out.set(processSiv(encKey, tag, plaintext));\n            encKey.fill(0);\n            authKey.fill(0);\n            return out;\n        },\n        decrypt: (ciphertext) => {\n            ensureBytes(ciphertext);\n            CIPHER_LIMIT(ciphertext.length);\n            const tag = ciphertext.subarray(-tagLength);\n            const { encKey, authKey } = deriveKeys();\n            const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n            const expectedTag = _computeTag(encKey, authKey, plaintext);\n            encKey.fill(0);\n            authKey.fill(0);\n            if (!equalBytes(tag, expectedTag))\n                throw new Error('invalid polyval tag');\n            return plaintext;\n        },\n    };\n});\nfunction isBytes32(a) {\n    return (a != null &&\n        typeof a === 'object' &&\n        (a instanceof Uint32Array || a.constructor.name === 'Uint32Array'));\n}\nfunction encryptBlock(xk, block) {\n    ensureBytes(block, 16);\n    if (!isBytes32(xk))\n        throw new Error('_encryptBlock accepts result of expandKeyLE');\n    const b32 = u32(block);\n    let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n    (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n    return block;\n}\nfunction decryptBlock(xk, block) {\n    ensureBytes(block, 16);\n    if (!isBytes32(xk))\n        throw new Error('_decryptBlock accepts result of expandKeyLE');\n    const b32 = u32(block);\n    let { s0, s1, s2, s3 } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n    (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n    return block;\n}\n// Highly unsafe private functions for implementing new modes or ciphers based on AES\n// Can change at any time, no API guarantees\nexport const unsafe = {\n    expandKeyLE,\n    expandKeyDecLE,\n    encrypt,\n    decrypt,\n    encryptBlock,\n    decryptBlock,\n    ctrCounter,\n    ctr32,\n};\n", "import { EncryptedURI, EncryptedURIDecrypter, EncryptedURIEncrypter } from \"@encrypted-uri/core\";\nimport { cbc, ecb, ctr, gcm, siv } from '@noble/ciphers/aes';\nimport { utf8ToBytes } from \"@noble/ciphers/utils\";\nfunction getInitializationVector(encryptedUriDecoded) {\n    return encryptedUriDecoded?.params?.iv || encryptedUriDecoded?.queryString || '';\n}\nfunction getNumberOnce(encryptedUriDecoded) {\n    return encryptedUriDecoded?.params?.no || encryptedUriDecoded?.queryString || '';\n}\nclass EncryptedURIAESCBCEncrypter extends EncryptedURIEncrypter {\n    constructor(params) {\n        super(params);\n        this.params = params;\n    }\n    encrypt() {\n        const key = utf8ToBytes(this.params.key);\n        const iv = getInitializationVector(this.params);\n        const content = utf8ToBytes(this.params.content);\n        return {\n            algorithm: 'aes/cbc',\n            cypher: cbc(key, utf8ToBytes(iv))\n                .encrypt(content)\n                .toString(),\n            params: { iv }\n        };\n    }\n}\nclass EncryptedURIAESCBCDecrypter extends EncryptedURIDecrypter {\n    constructor(decoded, key) {\n        super(decoded);\n        this.key = key;\n    }\n    decrypt() {\n        const key = utf8ToBytes(this.key);\n        const iv = utf8ToBytes(getInitializationVector(this.decoded));\n        const cypher = utf8ToBytes(this.decoded.cypher);\n        return cbc(key, iv)\n            .decrypt(cypher)\n            .toString();\n    }\n}\nclass EncryptedURIAESCTREncrypter extends EncryptedURIEncrypter {\n    constructor(params) {\n        super(params);\n        this.params = params;\n    }\n    encrypt() {\n        const key = utf8ToBytes(this.params.key);\n        const iv = getInitializationVector(this.params);\n        const content = utf8ToBytes(this.params.content);\n        return {\n            algorithm: 'aes/ctr',\n            cypher: ctr(key, utf8ToBytes(iv))\n                .encrypt(content)\n                .toString(),\n            params: { iv }\n        };\n    }\n}\nclass EncryptedURIAESCTRDecrypter extends EncryptedURIDecrypter {\n    constructor(decoded, key) {\n        super(decoded);\n        this.key = key;\n    }\n    decrypt() {\n        const key = utf8ToBytes(this.key);\n        const iv = utf8ToBytes(getInitializationVector(this.decoded));\n        const cypher = utf8ToBytes(this.decoded.cypher || '');\n        return ctr(key, iv)\n            .decrypt(cypher)\n            .toString();\n    }\n}\nclass EncryptedURIAESECBEncrypter extends EncryptedURIEncrypter {\n    constructor(params) {\n        super(params);\n        this.params = params;\n    }\n    encrypt() {\n        const key = utf8ToBytes(this.params.key);\n        const content = utf8ToBytes(this.params.content);\n        return {\n            algorithm: 'aes/ecb',\n            cypher: ecb(key)\n                .encrypt(content)\n                .toString()\n        };\n    }\n}\nclass EncryptedURIAESECBDecrypter extends EncryptedURIDecrypter {\n    constructor(decoded, key) {\n        super(decoded);\n        this.key = key;\n    }\n    decrypt() {\n        const key = utf8ToBytes(this.key);\n        const cypher = utf8ToBytes(this.decoded.cypher || '');\n        return ecb(key)\n            .decrypt(cypher)\n            .toString();\n    }\n}\nclass EncryptedURIAESGCMEncrypter extends EncryptedURIEncrypter {\n    constructor(params) {\n        super(params);\n        this.params = params;\n    }\n    encrypt() {\n        const key = utf8ToBytes(this.params.key);\n        const nonce = getNumberOnce(this.params);\n        const content = utf8ToBytes(this.params.content);\n        return {\n            algorithm: 'aes/gcm',\n            cypher: gcm(key, utf8ToBytes(nonce))\n                .encrypt(content)\n                .toString(),\n            params: { no: nonce }\n        };\n    }\n}\nclass EncryptedURIAESSIVDecrypter extends EncryptedURIDecrypter {\n    constructor(decoded, key) {\n        super(decoded);\n        this.key = key;\n    }\n    decrypt() {\n        const key = utf8ToBytes(this.key);\n        const nonce = utf8ToBytes(getNumberOnce(this.decoded));\n        const cypher = utf8ToBytes(this.decoded.cypher);\n        return siv(key, nonce)\n            .decrypt(cypher)\n            .toString();\n    }\n}\nclass EncryptedURIAESSIVEncrypter extends EncryptedURIEncrypter {\n    constructor(params) {\n        super(params);\n        this.params = params;\n    }\n    encrypt() {\n        const key = utf8ToBytes(this.params.key);\n        const nonce = getNumberOnce(this.params);\n        const content = utf8ToBytes(this.params.content);\n        return {\n            algorithm: 'aes/gcm',\n            cypher: siv(key, utf8ToBytes(nonce))\n                .encrypt(content)\n                .toString(),\n            params: { no: nonce }\n        };\n    }\n}\nclass EncryptedURIAESGCMDecrypter extends EncryptedURIDecrypter {\n    constructor(decoded, key) {\n        super(decoded);\n        this.key = key;\n    }\n    decrypt() {\n        const key = utf8ToBytes(this.key);\n        const nonce = utf8ToBytes(getNumberOnce(this.decoded));\n        const cypher = utf8ToBytes(this.decoded.cypher);\n        return gcm(key, nonce)\n            .decrypt(cypher)\n            .toString();\n    }\n}\nexport function supportAES() {\n    EncryptedURI.setAlgorithm('', EncryptedURIAESCBCEncrypter, EncryptedURIAESCBCDecrypter);\n    EncryptedURI.setAlgorithm('aes', EncryptedURIAESCBCEncrypter, EncryptedURIAESCBCDecrypter);\n    EncryptedURI.setAlgorithm('aes/cbc', EncryptedURIAESCBCEncrypter, EncryptedURIAESCBCDecrypter);\n    EncryptedURI.setAlgorithm('aes/ebc', EncryptedURIAESECBEncrypter, EncryptedURIAESECBDecrypter);\n    EncryptedURI.setAlgorithm('aes/ctr', EncryptedURIAESCTREncrypter, EncryptedURIAESCTRDecrypter);\n    EncryptedURI.setAlgorithm('aes/gcm', EncryptedURIAESGCMEncrypter, EncryptedURIAESGCMDecrypter);\n    EncryptedURI.setAlgorithm('aes/siv', EncryptedURIAESSIVEncrypter, EncryptedURIAESSIVDecrypter);\n}\n"],
  "mappings": "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",
  "names": ["isLE", "isBytes", "bytes", "BLOCK_SIZE", "POLY", "mul2", "t0", "t1", "t2", "t3", "ctr", "i", "isLE", "ecb", "cbc", "gcm", "siv"]
}
